C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #include <eeprom.h>
   3          #define NEXIE_PORT P1
   4          
   5          sbit SER_L = P0^0;
   6          sbit OE_L = P0^1;
   7          sbit RCLK_L = P0^2;
   8          sbit SRCLK_L = P0^3;
   9          sbit SRCLR_L = P0^4;
  10          
  11          sbit SER_R = P2^0;
  12          sbit OE_R = P2^1;
  13          sbit RCLK_R = P2^2;
  14          sbit SRCLK_R = P2^3;
  15          sbit SRCLR_R = P2^4;
  16          
  17          sbit SER_B = P2^5;
  18          sbit RCLK_B = P2^6;
  19          sbit SRCLK_B = P2^7;
  20          
  21          sbit BUTTON_UP = P3^6;
  22          sbit BUTTON_DOWN = P3^4;
  23          sbit BUTTON_LEFT = P3^7;
  24          sbit BUTTON_RIGHT = P3^3;
  25          sbit BUTTON_MIDDLE = P3^5;
  26          sbit BUTTON_HIDDEN = P0^5;
  27          
  28          #define RED 0
  29          #define GREEN 1
  30          
  31          #define LEFT 0
  32          #define RIGHT 1
  33          
  34          #define ROW_SIZE 8
  35          #define COLUMN_SIZE 16
  36          #define AREA_SIZE 128
  37          
  38          #define GETX(position) (position)&0x0F
  39          #define GETY(position) ((position)>>4)&0x07
  40          #define RESET_VRAM(position) vram[GETY(position)][GETX(position)] = 0;
  41          #define VRAM(x,y) vram[y][x]
  42          
  43          #define SCAN_PERIOD_H 0xF4
  44          #define SCAN_PERIOD_L 0x60
  45          
  46          #define TOWARD_NORTH 0x00
  47          #define TOWARD_EAST 0x01
  48          #define TOWARD_SOUTH 0x02
  49          #define TOWARD_WEST 0x03
  50          char orientation;
  51          
  52          #define TURN_LEFT 0xFF
  53          #define TURN_RIGHT 0x01
  54          #define GO_STRAIGHT 0x00
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 2   

  55          char forwardDirection;
  56          
  57          #define ALIVE 0x00
  58          #define TURN_NORTH 0x01
  59          #define TURN_EAST 0x02
  60          #define TURN_SOUTH 0x03
  61          #define TURN_WEST 0x04
  62          #define DEAD 0x05
  63          char state;
  64          
  65          /************************************************
  66           *                     VRAMS                    *
  67           ************************************************/
  68          char xdata vram[8][16];
  69          //{
  70          //  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  71          //  {0,2,2,0,0,2,2,0,0,1,1,0,0,1,1,0},
  72          //  {2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1},
  73          //  {2,2,3,2,2,3,2,2,1,1,1,1,1,1,1,1},
  74          //  {0,2,2,3,3,2,2,0,0,1,1,1,1,1,1,0},
  75          //  {0,0,2,2,2,2,0,0,0,0,1,1,1,1,0,0},
  76          //  {0,0,0,2,2,0,0,0,0,0,0,1,1,0,0,0},
  77          //  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  78          //};
  79          char digits[4];//digits on nixie
  80          
  81          /************************************************
  82           *                  code tables                 *
  83           ************************************************/
  84          char code colorfulLightCode[] = {
  85            0x40,//extinguish
  86            0x00//light up
  87          };
  88          char code buzzerCode[] = {
  89            0x80,//extinguish
  90            0x00//light up
  91          };
  92          char code digitSelectCode[] = {0x30,0x00,0x20,0x10};
  93          char code numberCode[] = {0x00,0x01,0x08,0x09,0x04,0x05,0x0C,0x0D,0x02,0x03,0xFF};
  94          /* ROW MAP
  95           * 0x0001 0x0002 0x0004 0x0008 0x0010 0x0020 0x0040 0x0080 0x0100 0x0200 0x0400 0x0800 0x1000 0x2000 0x400
             -0 0x8000 
  96           * R4     R3     R2     R5     R6     R7     R8     R1     L1     L2     L8     L7     L6     L3     L4     
             -L5
  97           *
  98           * COLUMN MAP(RED left)
  99           * 0xXXFE 0xXXFD 0xXXFB 0xXXF7 0xXXEF 0xXXDF 0xXXBF 0xXX7F
 100           * 8      7      6      5      4      3      2      1
 101           *
 102           * COLUMN MAP(RED right)
 103           * 0xXXFE 0xXXFD 0xXXFB 0xXXF7 0xXXEF 0xXXDF 0xXXBF 0xXX7F
 104           * 8      7      6      5      4      3      2      1
 105           *
 106           * COLUMN MAP(GREEN left)
 107           * 0xFEXX 0xFDXX 0xFBXX 0xF7XX 0xEFXX 0xDFXX 0xBFXX 0x7FXX
 108           * 8      7      6      5      4      3      2      1
 109           *
 110           * COLUMN MAP(GREEN right)
 111           * 0xFEXX 0xFDXX 0xFBXX 0xF7XX 0xEFXX 0xDFXX 0xBFXX 0x7FXX
 112           * 6      7      8      5      4      3      2      1
 113           */
 114          int code rowSelectCode[] = {0x0180,0x0204,0x2002,0x4001,0x8008,0x1010,0x0820,0x0440};
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 3   

 115          int code columnSelectCode[2][2][ROW_SIZE] = {
 116            {
 117              {0xFF7F, 0xFFBF, 0xFFDF, 0xFFEF, 0xFFF7, 0xFFFB, 0xFFFD, 0xFFFE},
 118              {0xFF7F, 0xFFBF, 0xFFDF, 0xFFEF, 0xFFF7, 0xFFFB, 0xFFFD, 0xFFFE}
 119            },
 120            {
 121              {0x7FFF, 0xBFFF, 0xDFFF, 0xEFFF, 0xF7FF, 0xFBFF, 0xFDFF, 0xFEFF},
 122              {0x7FFF, 0xBFFF, 0xDFFF, 0xEFFF, 0xF7FF, 0xFEFF, 0xFDFF, 0xFBFF}
 123            }
 124          };
 125          char code forwardCode[4] = {0xF0, 0x01, 0x10, 0xFF};
 126          
 127          /************************************************
 128           *    Variables in timer interrupt function     *
 129           ************************************************/
 130          unsigned char interruptCounter;
 131          char refreshCounter;
 132          char refreshCounter_buffer;
 133          char buzzCounter;
 134          char digitSelect;
 135          int leftColSelectCode[2][ROW_SIZE];
 136          int rightColSelectCode[2][ROW_SIZE];
 137          char scanner;
 138          char buzz;
 139          bit isBuzzing;
 140          bit colorfulLight;
 141          
 142          /************************************************
 143           *               data structure                 *
 144           ************************************************/
 145          char xdata snake[AREA_SIZE];
 146          unsigned char ptrHead = 0;
 147          unsigned char ptrTail = 0;
 148          unsigned char length = 0;
 149          char food = 0xFF;
 150          
 151          /************************************************
 152           *               other variables                *
 153           ************************************************/
 154          char nextOrientation;
 155          char currentPosition;
 156          char nextPosition;
 157          char currentX;
 158          char currentY;
 159          bit biteSelf;
 160          bit hitWall;
 161          bit isRefreshing;
 162          unsigned char rand;
 163          int point;
 164          int highestPoint;
 165          
 166          /************************************************
 167           *             Functions of 74HC595             *
 168           ************************************************/
 169          void Load_74HC595(int dat_B, int dat_L, int dat_R){
 170   1        char i;
 171   1        for(i=0;i<16;i++){
 172   2          SER_B=dat_B&0x8000;
 173   2          dat_B=dat_B<<1;
 174   2          SER_L=dat_L&0x8000;
 175   2          dat_L=dat_L<<1;
 176   2          SER_R=dat_R&0x8000;
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 4   

 177   2          dat_R=dat_R<<1;
 178   2         
 179   2          SRCLK_B=1;
 180   2          SRCLK_L=1;
 181   2          SRCLK_R=1;
 182   2          SRCLK_B=0;
 183   2          SRCLK_L=0;
 184   2          SRCLK_R=0;
 185   2        }
 186   1      }
 187          void Output_74HC595(){
 188   1        RCLK_B=1;
 189   1        RCLK_L=1;
 190   1        RCLK_R=1;
 191   1        RCLK_B=0;
 192   1        RCLK_L=0;
 193   1        RCLK_R=0;
 194   1      }
 195          
 196          void refresh(){
 197   1        char i,j;
 198   1        refreshCounter_buffer=refreshCounter+1;
 199   1        refreshCounter_buffer%=2;
 200   1        for(i=0;i<8;i++){
 201   2          leftColSelectCode[refreshCounter_buffer][i] = 0xFFFF;
 202   2          rightColSelectCode[refreshCounter_buffer][i] = 0xFFFF;
 203   2          for(j=0;j<8;j++){
 204   3            leftColSelectCode[refreshCounter_buffer][i] &= (vram[i][j]&0x01)!=0    ? columnSelectCode[refreshCounte
             -r][LEFT][j]   : 0xFFFF;
 205   3            leftColSelectCode[refreshCounter_buffer][i] &= (vram[i][j]&0x02)!=0  ? columnSelectCode[refreshCounter_
             -buffer][LEFT][j] : 0xFFFF;
 206   3            rightColSelectCode[refreshCounter_buffer][i]&= (vram[i][j+8]&0x01)!=0  ? columnSelectCode[refreshCounte
             -r][RIGHT][j]  : 0xFFFF;
 207   3            rightColSelectCode[refreshCounter_buffer][i]&= (vram[i][j+8]&0x02)!=0? columnSelectCode[refreshCounter_
             -buffer][RIGHT][j]: 0xFFFF;
 208   3          }
 209   2        }
 210   1        isRefreshing = 1;
 211   1        refreshCounter=refreshCounter_buffer;
 212   1        isRefreshing = 0;
 213   1      }
 214          
 215          /************************************************
 216           *           data structure function            *
 217           ************************************************/
 218          void AddHead(char newNode){
 219   1        char ytemp = GETY(newNode);
 220   1        char xtemp = GETX(newNode);
 221   1        snake[ptrHead] = newNode;
 222   1        ptrHead = (ptrHead+1)%AREA_SIZE;
 223   1        length++;
 224   1        vram[ytemp][xtemp] = (xtemp+ytemp)%2==0?1:2;
 225   1      }
 226          void DeleteTail(){
 227   1        RESET_VRAM(snake[ptrTail]);
 228   1        ptrTail = (ptrTail+1)%AREA_SIZE;
 229   1        length--;
 230   1      }
 231          
 232          
 233          /************************************************
 234           *              logic and actions               *
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 5   

 235           ************************************************/
 236          void SetFood(){
 237   1        char i,j,k;
 238   1        rand = TL1&0x7F;//get random number
 239   1        rand = rand%(AREA_SIZE-length)+1;
 240   1        k=0;
 241   1        for(i=0;i<8;i++){
 242   2          for(j=0;j<16;j++){
 243   3            if(vram[i][j]==0){
 244   4              k++;
 245   4              if(k>=rand){
 246   5                vram[i][j]=3;
 247   5                food = j|(i<<4);
 248   5                return;
 249   5              }
 250   4            }
 251   3          }
 252   2        }
 253   1        
 254   1      }
 255          void Score(){
 256   1        char i;
 257   1        AddHead(food);
 258   1        SetFood();
 259   1        point++;
 260   1        isBuzzing=1;
 261   1        buzzCounter=0;
 262   1        for(i=0;i<4;i++){
 263   2          digits[i]++;
 264   2          if(digits[i]>=10){
 265   3            digits[i]-=10;
 266   3          }
 267   2          else{
 268   3            break;
 269   3          }
 270   2        }
 271   1      }
 272          char Creep(){
 273   1        nextOrientation = (orientation+forwardDirection)&0x03;
 274   1        currentPosition = snake[(ptrTail+length-1)%AREA_SIZE];
 275   1        nextPosition = currentPosition+forwardCode[nextOrientation];
 276   1        currentX = GETX(currentPosition);
 277   1        currentY = GETY(currentPosition);
 278   1        biteSelf = VRAM(GETX(nextPosition),GETY(nextPosition));
 279   1        hitWall = 
 280   1          (currentX==0        &&  nextOrientation==TOWARD_WEST) ||
 281   1          (currentX==COLUMN_SIZE-1  &&  nextOrientation==TOWARD_EAST) ||
 282   1          (currentY==0        &&  nextOrientation==TOWARD_NORTH) ||
 283   1          (currentY==ROW_SIZE-1   &&  nextOrientation==TOWARD_SOUTH);
 284   1        if(nextPosition==food){
 285   2          Score();
 286   2        }
 287   1        else if(biteSelf||hitWall){
 288   2          return DEAD;
 289   2        }
 290   1        else{
 291   2          AddHead(nextPosition);
 292   2          DeleteTail();
 293   2        }
 294   1        orientation = nextOrientation;
 295   1        return ALIVE;
 296   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 6   

 297          char FSM(){
 298   1        switch(state){
 299   2          case ALIVE:
 300   2            forwardDirection=GO_STRAIGHT;
 301   2            break;
 302   2          case TURN_NORTH:
 303   2            if(orientation==TOWARD_WEST)    {forwardDirection=TURN_RIGHT;}
 304   2            else if(orientation==TOWARD_EAST) {forwardDirection=TURN_LEFT;}
 305   2            else              {forwardDirection=GO_STRAIGHT;}
 306   2            break;
 307   2          case TURN_EAST:
 308   2            if(orientation==TOWARD_NORTH)   {forwardDirection=TURN_RIGHT;}
 309   2            else if(orientation==TOWARD_SOUTH){forwardDirection=TURN_LEFT;}
 310   2            else              {forwardDirection=GO_STRAIGHT;}
 311   2            break;
 312   2          case TURN_SOUTH:
 313   2            if(orientation==TOWARD_EAST)    {forwardDirection=TURN_RIGHT;}
 314   2            else if(orientation==TOWARD_WEST) {forwardDirection=TURN_LEFT;}
 315   2            else              {forwardDirection=GO_STRAIGHT;}
 316   2            break;
 317   2          case TURN_WEST:
 318   2            if(orientation==TOWARD_SOUTH)   {forwardDirection=TURN_RIGHT;}
 319   2            else if(orientation==TOWARD_NORTH){forwardDirection=TURN_LEFT;}
 320   2            else              {forwardDirection=GO_STRAIGHT;}
 321   2            break;
 322   2          default:
 323   2            forwardDirection=GO_STRAIGHT;
 324   2            break;
 325   2        }
 326   1        return Creep();
 327   1      }
 328          void restart(){
 329   1        char i,j;
 330   1        for(i=0;i<8;i++){
 331   2          for(j=0;j<16;j++){
 332   3            vram[i][j]=0;
 333   3          }
 334   2        }
 335   1        
 336   1        ptrHead = 0;
 337   1        ptrTail = 0;
 338   1        length = 0;
 339   1        interruptCounter=0;
 340   1        refreshCounter=0;
 341   1        colorfulLight=0;
 342   1        point=0;
 343   1        isBuzzing=0;
 344   1        
 345   1        AddHead(0x00);
 346   1        AddHead(0x01);
 347   1        AddHead(0x02);
 348   1        orientation = TOWARD_EAST;
 349   1        forwardDirection = GO_STRAIGHT;
 350   1        state = ALIVE;
 351   1        
 352   1        SetFood();
 353   1        refresh();
 354   1      }
 355          /************************************************
 356           *                 Initializer                  *
 357           ************************************************/
 358          void initializer(){
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 7   

 359   1        char i;
 360   1        TMOD=0x21;//Timer1 8bit_auto_load Timer0 16bit_normal
 361   1        
 362   1        TH0=SCAN_PERIOD_H;
 363   1        TL0=SCAN_PERIOD_L;
 364   1      
 365   1        TH1=0x00;
 366   1        TL1=0x00;
 367   1        
 368   1        //Eable timers
 369   1        TR0=1;
 370   1        TR1=1;
 371   1      
 372   1        
 373   1        //External interruption 0 is triggered by negative edge
 374   1        IT0=1;
 375   1        
 376   1        IP=0x02;
 377   1        
 378   1        highestPoint=0;
 379   1        //read highest point
 380   1        digits[0] = byte_read(0x2001);
 381   1        digits[1] = byte_read(0x2002);
 382   1        digits[2] = byte_read(0x2003);
 383   1        digits[3] = byte_read(0x2004);
 384   1        for(i=0;i<3;i++){
 385   2          highestPoint += digits[3-i];
 386   2          highestPoint *= 10;
 387   2        }
 388   1        highestPoint += digits[0];
 389   1        
 390   1        restart();
 391   1        
 392   1        //Only eable timer0 IRQ, timer1 functions as a random number generator
 393   1        ET0=1;
 394   1        ET1=0;
 395   1      
 396   1        //Interrupt switch
 397   1        EA=1;
 398   1      }
 399          
 400          void main(void){
 401   1        char i;
 402   1        initializer();
 403   1        //wait for button
 404   1        while(BUTTON_MIDDLE){
 405   2          if(BUTTON_HIDDEN==0){
 406   3            SectorErase(0x2000);
 407   3            byte_write(0x2001,0);
 408   3            byte_write(0x2002,0);
 409   3            byte_write(0x2003,0);
 410   3            byte_write(0x2004,0);
 411   3            highestPoint=0;
 412   3          }
 413   2        }
 414   1        //reset nixie
 415   1        for(i=0;i<4;i++){
 416   2          digits[i]=0;
 417   2        }
 418   1        EX0=1;
 419   1        while(1){
 420   2          if(state==DEAD){
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 8   

 421   3            EX0=0;
 422   3            if(point>=highestPoint){
 423   4              SectorErase(0x2000);
 424   4              byte_write(0x2001,digits[0]);
 425   4              byte_write(0x2002,digits[1]);
 426   4              byte_write(0x2003,digits[2]);
 427   4              byte_write(0x2004,digits[3]);
 428   4              highestPoint=point;
 429   4              colorfulLight=1;
 430   4            }
 431   3            else{
 432   4              colorfulLight=0;
 433   4            }
 434   3            while(BUTTON_MIDDLE){
 435   4            }
 436   3            restart();
 437   3            for(i=0;i<4;i++){
 438   4              digits[i]=0;
 439   4            }
 440   3            EX0=1;
 441   3          }
 442   2          else if(state==ALIVE){
 443   3            if(BUTTON_UP==0){
 444   4              state = TURN_NORTH;
 445   4            }
 446   3            else if(BUTTON_DOWN==0){
 447   4              state = TURN_SOUTH;
 448   4            }
 449   3            else if(BUTTON_LEFT==0){
 450   4              state = TURN_WEST;
 451   4            }
 452   3            else if(BUTTON_RIGHT==0){
 453   4              state = TURN_EAST;
 454   4            }
 455   3            else{
 456   4              state = ALIVE;
 457   4            }
 458   3          }
 459   2          else{
 460   3          }
 461   2        }
 462   1      }
 463          void EX0_IRQ(void) interrupt 0{
 464   1        state=FSM();
 465   1        if(state!=DEAD){
 466   2          refresh();
 467   2        }
 468   1      }
 469          void Timer0_IRQ(void) interrupt 1{
 470   1        interruptCounter++;
 471   1        if(isBuzzing){
 472   2          isBuzzing=((buzzCounter++)<=0x1F);
 473   2        }
 474   1        digitSelect = interruptCounter&0x03;
 475   1        scanner = interruptCounter&0x07;
 476   1        buzz = interruptCounter&(isBuzzing?0x01:0x00);
 477   1        
 478   1        
 479   1        NEXIE_PORT = 
 480   1          digitSelectCode[digitSelect] |
 481   1          numberCode[digits[digitSelect]] |
 482   1          colorfulLightCode[colorfulLight] |
C51 COMPILER V9.60.0.0   MAIN                                                              02/22/2022 17:58:21 PAGE 9   

 483   1          buzzerCode[buzz];
 484   1        
 485   1        if(!isRefreshing){
 486   2          OE_R = 1;
 487   2          OE_L = 1;
 488   2          Load_74HC595(rowSelectCode[scanner],leftColSelectCode[refreshCounter][scanner],rightColSelectCode[refres
             -hCounter][scanner]);
 489   2          Output_74HC595();
 490   2          OE_R = 0;
 491   2          OE_L = 0;
 492   2        }
 493   1        
 494   1        TH0=SCAN_PERIOD_H;
 495   1        TL0=SCAN_PERIOD_L;
 496   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2613    ----
   CONSTANT SIZE    =    103    ----
   XDATA SIZE       =    256    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     92       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
